{"ast":null,"code":"'use strict';\n\nvar ctx = require('./$.ctx'),\n    $export = require('./$.export'),\n    toObject = require('./$.to-object'),\n    call = require('./$.iter-call'),\n    isArrayIter = require('./$.is-array-iter'),\n    toLength = require('./$.to-length'),\n    getIterFn = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./$.iter-detect')(function (iter) {\n  Array.from(iter);\n}), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike\n  /*, mapfn = undefined, thisArg = undefined*/\n  ) {\n    var O = toObject(arrayLike),\n        C = typeof this == 'function' ? this : Array,\n        $$ = arguments,\n        $$len = $$.length,\n        mapfn = $$len > 1 ? $$[1] : undefined,\n        mapping = mapfn !== undefined,\n        index = 0,\n        iterFn = getIterFn(O),\n        length,\n        result,\n        step,\n        iterator;\n    if (mapping) mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case\n\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;\n      }\n    } else {\n      length = toLength(O.length);\n\n      for (result = new C(length); length > index; index++) {\n        result[index] = mapping ? mapfn(O[index], index) : O[index];\n      }\n    }\n\n    result.length = index;\n    return result;\n  }\n});","map":{"version":3,"sources":["/Users/victoriablackburn/TripStagram/client/node_modules/react-bootstrap-validation/node_modules/core-js/library/modules/es6.array.from.js"],"names":["ctx","require","$export","toObject","call","isArrayIter","toLength","getIterFn","S","F","iter","Array","from","arrayLike","O","C","$$","arguments","$$len","length","mapfn","undefined","mapping","index","iterFn","result","step","iterator","next","done","value"],"mappings":"AAAA;;AACA,IAAIA,GAAG,GAAWC,OAAO,CAAC,SAAD,CAAzB;AAAA,IACIC,OAAO,GAAOD,OAAO,CAAC,YAAD,CADzB;AAAA,IAEIE,QAAQ,GAAMF,OAAO,CAAC,eAAD,CAFzB;AAAA,IAGIG,IAAI,GAAUH,OAAO,CAAC,eAAD,CAHzB;AAAA,IAIII,WAAW,GAAGJ,OAAO,CAAC,mBAAD,CAJzB;AAAA,IAKIK,QAAQ,GAAML,OAAO,CAAC,eAAD,CALzB;AAAA,IAMIM,SAAS,GAAKN,OAAO,CAAC,4BAAD,CANzB;;AAOAC,OAAO,CAACA,OAAO,CAACM,CAAR,GAAYN,OAAO,CAACO,CAAR,GAAY,CAACR,OAAO,CAAC,iBAAD,CAAP,CAA2B,UAASS,IAAT,EAAc;AAAEC,EAAAA,KAAK,CAACC,IAAN,CAAWF,IAAX;AAAmB,CAA9D,CAA1B,EAA2F,OAA3F,EAAoG;AACzG;AACAE,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAcC;AAAS;AAAvB,IAAoE;AACxE,QAAIC,CAAC,GAASX,QAAQ,CAACU,SAAD,CAAtB;AAAA,QACIE,CAAC,GAAS,OAAO,IAAP,IAAe,UAAf,GAA4B,IAA5B,GAAmCJ,KADjD;AAAA,QAEIK,EAAE,GAAQC,SAFd;AAAA,QAGIC,KAAK,GAAKF,EAAE,CAACG,MAHjB;AAAA,QAIIC,KAAK,GAAKF,KAAK,GAAG,CAAR,GAAYF,EAAE,CAAC,CAAD,CAAd,GAAoBK,SAJlC;AAAA,QAKIC,OAAO,GAAGF,KAAK,KAAKC,SALxB;AAAA,QAMIE,KAAK,GAAK,CANd;AAAA,QAOIC,MAAM,GAAIjB,SAAS,CAACO,CAAD,CAPvB;AAAA,QAQIK,MARJ;AAAA,QAQYM,MARZ;AAAA,QAQoBC,IARpB;AAAA,QAQ0BC,QAR1B;AASA,QAAGL,OAAH,EAAWF,KAAK,GAAGpB,GAAG,CAACoB,KAAD,EAAQF,KAAK,GAAG,CAAR,GAAYF,EAAE,CAAC,CAAD,CAAd,GAAoBK,SAA5B,EAAuC,CAAvC,CAAX,CAV6D,CAWxE;;AACA,QAAGG,MAAM,IAAIH,SAAV,IAAuB,EAAEN,CAAC,IAAIJ,KAAL,IAAcN,WAAW,CAACmB,MAAD,CAA3B,CAA1B,EAA+D;AAC7D,WAAIG,QAAQ,GAAGH,MAAM,CAACpB,IAAP,CAAYU,CAAZ,CAAX,EAA2BW,MAAM,GAAG,IAAIV,CAAJ,EAAxC,EAA+C,CAAC,CAACW,IAAI,GAAGC,QAAQ,CAACC,IAAT,EAAR,EAAyBC,IAAzE,EAA+EN,KAAK,EAApF,EAAuF;AACrFE,QAAAA,MAAM,CAACF,KAAD,CAAN,GAAgBD,OAAO,GAAGlB,IAAI,CAACuB,QAAD,EAAWP,KAAX,EAAkB,CAACM,IAAI,CAACI,KAAN,EAAaP,KAAb,CAAlB,EAAuC,IAAvC,CAAP,GAAsDG,IAAI,CAACI,KAAlF;AACD;AACF,KAJD,MAIO;AACLX,MAAAA,MAAM,GAAGb,QAAQ,CAACQ,CAAC,CAACK,MAAH,CAAjB;;AACA,WAAIM,MAAM,GAAG,IAAIV,CAAJ,CAAMI,MAAN,CAAb,EAA4BA,MAAM,GAAGI,KAArC,EAA4CA,KAAK,EAAjD,EAAoD;AAClDE,QAAAA,MAAM,CAACF,KAAD,CAAN,GAAgBD,OAAO,GAAGF,KAAK,CAACN,CAAC,CAACS,KAAD,CAAF,EAAWA,KAAX,CAAR,GAA4BT,CAAC,CAACS,KAAD,CAApD;AACD;AACF;;AACDE,IAAAA,MAAM,CAACN,MAAP,GAAgBI,KAAhB;AACA,WAAOE,MAAP;AACD;AA1BwG,CAApG,CAAP","sourcesContent":["'use strict';\nvar ctx         = require('./$.ctx')\n  , $export     = require('./$.export')\n  , toObject    = require('./$.to-object')\n  , call        = require('./$.iter-call')\n  , isArrayIter = require('./$.is-array-iter')\n  , toLength    = require('./$.to-length')\n  , getIterFn   = require('./core.get-iterator-method');\n$export($export.S + $export.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n    var O       = toObject(arrayLike)\n      , C       = typeof this == 'function' ? this : Array\n      , $$      = arguments\n      , $$len   = $$.length\n      , mapfn   = $$len > 1 ? $$[1] : undefined\n      , mapping = mapfn !== undefined\n      , index   = 0\n      , iterFn  = getIterFn(O)\n      , length, result, step, iterator;\n    if(mapping)mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;\n      }\n    } else {\n      length = toLength(O.length);\n      for(result = new C(length); length > index; index++){\n        result[index] = mapping ? mapfn(O[index], index) : O[index];\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}