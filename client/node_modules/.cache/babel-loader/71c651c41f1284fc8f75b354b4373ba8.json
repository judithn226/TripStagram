{"ast":null,"code":"var Rules = require('./rules');\n\nvar Lang = require('./lang');\n\nvar Errors = require('./errors');\n\nvar Attributes = require('./attributes');\n\nvar AsyncResolvers = require('./async');\n\nvar Validator = function (input, rules, customMessages) {\n  var lang = Validator.getDefaultLang();\n  this.input = input || {};\n  this.messages = Lang._make(lang);\n\n  this.messages._setCustom(customMessages);\n\n  this.setAttributeFormatter(Validator.prototype.attributeFormatter);\n  this.errors = new Errors();\n  this.errorCount = 0;\n  this.hasAsync = false;\n  this.rules = this._parseRules(rules);\n};\n\nValidator.prototype = {\n  constructor: Validator,\n\n  /**\n   * Default language\n   *\n   * @type {string}\n   */\n  lang: 'en',\n\n  /**\n   * Numeric based rules\n   *\n   * @type {array}\n   */\n  numericRules: ['integer', 'numeric'],\n\n  /**\n   * Attribute formatter.\n   *\n   * @type {function}\n   */\n  attributeFormatter: Attributes.formatter,\n\n  /**\n   * Run validator\n   *\n   * @return {boolean} Whether it passes; true = passes, false = fails\n   */\n  check: function () {\n    var self = this;\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {\n        ruleOptions = attributeRules[i];\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);\n\n        if (!rulePassed) {\n          this._addFailure(rule);\n        }\n\n        if (this._shouldStopValidating(attribute, rulePassed)) {\n          break;\n        }\n      }\n    }\n\n    return this.errorCount === 0;\n  },\n\n  /**\n   * Run async validator\n   *\n   * @param {function} passes\n   * @param {function} fails\n   * @return {void}\n   */\n  checkAsync: function (passes, fails) {\n    var _this = this;\n\n    passes = passes || function () {};\n\n    fails = fails || function () {};\n\n    var failsOne = function (rule, message) {\n      _this._addFailure(rule, message);\n    };\n\n    var resolvedAll = function (allPassed) {\n      if (allPassed) {\n        passes();\n      } else {\n        fails();\n      }\n    };\n\n    var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);\n\n    var validateRule = function (inputValue, ruleOptions, attribute, rule) {\n      return function () {\n        var resolverIndex = asyncResolvers.add(rule);\n        rule.validate(inputValue, ruleOptions.value, attribute, function () {\n          asyncResolvers.resolve(resolverIndex);\n        });\n      };\n    };\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {\n        ruleOptions = attributeRules[i];\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        validateRule(inputValue, ruleOptions, attribute, rule)();\n      }\n    }\n\n    asyncResolvers.enableFiring();\n    asyncResolvers.fire();\n  },\n\n  /**\n   * Add failure and error message for given rule\n   *\n   * @param {Rule} rule\n   */\n  _addFailure: function (rule) {\n    var msg = this.messages.render(rule);\n    this.errors.add(rule.attribute, msg);\n    this.errorCount++;\n  },\n\n  /**\n   * Flatten nested object, normalizing { foo: { bar: 1 } } into: { 'foo.bar': 1 }\n   *\n   * @param  {object} nested object\n   * @return {object} flattened object\n   */\n  _flattenObject: function (obj) {\n    var flattened = {};\n\n    function recurse(current, property) {\n      if (!property && Object.getOwnPropertyNames(current).length === 0) {\n        return;\n      }\n\n      if (Object(current) !== current || Array.isArray(current)) {\n        flattened[property] = current;\n      } else {\n        var isEmpty = true;\n\n        for (var p in current) {\n          isEmpty = false;\n          recurse(current[p], property ? property + '.' + p : p);\n        }\n\n        if (isEmpty) {\n          flattened[property] = {};\n        }\n      }\n    }\n\n    if (obj) {\n      recurse(obj);\n    }\n\n    return flattened;\n  },\n\n  /**\n   * Extract value from nested object using string path with dot notation\n   *\n   * @param  {object} object to search in\n   * @param  {string} path inside object\n   * @return {any|void} value under the path\n   */\n  _objectPath: function (obj, path) {\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n      return obj[path];\n    }\n\n    var keys = path.replace(/\\[(\\w+)\\]/g, '.$1').replace(/^\\./, '').split('.');\n    var copy = {};\n\n    for (var attr in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n\n    for (var i = 0, l = keys.length; i < l; i++) {\n      if (typeof copy === 'object' && copy !== null && Object.hasOwnProperty.call(copy, keys[i])) {\n        copy = copy[keys[i]];\n      } else {\n        return;\n      }\n    }\n\n    return copy;\n  },\n\n  /**\n   * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }\n   *\n   * @param  {object} rules\n   * @return {object}\n   */\n  _parseRules: function (rules) {\n    var parsedRules = {};\n    rules = this._flattenObject(rules);\n\n    for (var attribute in rules) {\n      var rulesArray = rules[attribute];\n\n      this._parseRulesCheck(attribute, rulesArray, parsedRules);\n    }\n\n    return parsedRules;\n  },\n  _parseRulesCheck: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    if (attribute.indexOf('*') > -1) {\n      this._parsedRulesRecurse(attribute, rulesArray, parsedRules, wildCardValues);\n    } else {\n      this._parseRulesDefault(attribute, rulesArray, parsedRules, wildCardValues);\n    }\n  },\n  _parsedRulesRecurse: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var parentPath = attribute.substr(0, attribute.indexOf('*') - 1);\n\n    var propertyValue = this._objectPath(this.input, parentPath);\n\n    if (propertyValue) {\n      for (var propertyNumber = 0; propertyNumber < propertyValue.length; propertyNumber++) {\n        var workingValues = wildCardValues ? wildCardValues.slice() : [];\n        workingValues.push(propertyNumber);\n\n        this._parseRulesCheck(attribute.replace('*', propertyNumber), rulesArray, parsedRules, workingValues);\n      }\n    }\n  },\n  _parseRulesDefault: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var attributeRules = [];\n\n    if (rulesArray instanceof Array) {\n      rulesArray = this._prepareRulesArray(rulesArray);\n    }\n\n    if (typeof rulesArray === 'string') {\n      rulesArray = rulesArray.split('|');\n    }\n\n    for (var i = 0, len = rulesArray.length, rule; i < len; i++) {\n      rule = typeof rulesArray[i] === 'string' ? this._extractRuleAndRuleValue(rulesArray[i]) : rulesArray[i];\n\n      if (rule.value) {\n        rule.value = this._replaceWildCards(rule.value, wildCardValues);\n\n        this._replaceWildCardsMessages(wildCardValues);\n      }\n\n      if (Rules.isAsync(rule.name)) {\n        this.hasAsync = true;\n      }\n\n      attributeRules.push(rule);\n    }\n\n    parsedRules[attribute] = attributeRules;\n  },\n  _replaceWildCards: function (path, nums) {\n    if (!nums) {\n      return path;\n    }\n\n    var path2 = path;\n    nums.forEach(function (value) {\n      if (Array.isArray(path2)) {\n        path2 = path2[0];\n      }\n\n      const pos = path2.indexOf('*');\n\n      if (pos === -1) {\n        return path2;\n      }\n\n      path2 = path2.substr(0, pos) + value + path2.substr(pos + 1);\n    });\n\n    if (Array.isArray(path)) {\n      path[0] = path2;\n      path2 = path;\n    }\n\n    return path2;\n  },\n  _replaceWildCardsMessages: function (nums) {\n    var customMessages = this.messages.customMessages;\n    var self = this;\n    Object.keys(customMessages).forEach(function (key) {\n      if (nums) {\n        var newKey = self._replaceWildCards(key, nums);\n\n        customMessages[newKey] = customMessages[key];\n      }\n    });\n\n    this.messages._setCustom(customMessages);\n  },\n\n  /**\n   * Prepare rules if it comes in Array. Check for objects. Need for type validation.\n   *\n   * @param  {array} rulesArray\n   * @return {array}\n   */\n  _prepareRulesArray: function (rulesArray) {\n    var rules = [];\n\n    for (var i = 0, len = rulesArray.length; i < len; i++) {\n      if (typeof rulesArray[i] === 'object') {\n        for (var rule in rulesArray[i]) {\n          rules.push({\n            name: rule,\n            value: rulesArray[i][rule]\n          });\n        }\n      } else {\n        rules.push(rulesArray[i]);\n      }\n    }\n\n    return rules;\n  },\n\n  /**\n   * Determines if the attribute is supplied with the original data object.\n   *\n   * @param  {array} attribute\n   * @return {boolean}\n   */\n  _suppliedWithData: function (attribute) {\n    return this.input.hasOwnProperty(attribute);\n  },\n\n  /**\n   * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3\n   *\n   * @param  {string} ruleString min:3\n   * @return {object} object containing the name of the rule and value\n   */\n  _extractRuleAndRuleValue: function (ruleString) {\n    var rule = {},\n        ruleArray;\n    rule.name = ruleString;\n\n    if (ruleString.indexOf(':') >= 0) {\n      ruleArray = ruleString.split(':');\n      rule.name = ruleArray[0];\n      rule.value = ruleArray.slice(1).join(':');\n    }\n\n    return rule;\n  },\n\n  /**\n   * Determine if attribute has any of the given rules\n   *\n   * @param  {string}  attribute\n   * @param  {array}   findRules\n   * @return {boolean}\n   */\n  _hasRule: function (attribute, findRules) {\n    var rules = this.rules[attribute] || [];\n\n    for (var i = 0, len = rules.length; i < len; i++) {\n      if (findRules.indexOf(rules[i].name) > -1) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Determine if attribute has any numeric-based rules.\n   *\n   * @param  {string}  attribute\n   * @return {Boolean}\n   */\n  _hasNumericRule: function (attribute) {\n    return this._hasRule(attribute, this.numericRules);\n  },\n\n  /**\n   * Determine if rule is validatable\n   *\n   * @param  {Rule}   rule\n   * @param  {mixed}  value\n   * @return {boolean}\n   */\n  _isValidatable: function (rule, value) {\n    if (Array.isArray(value)) {\n      return true;\n    }\n\n    if (Rules.isImplicit(rule.name)) {\n      return true;\n    }\n\n    return this.getRule('required').validate(value);\n  },\n\n  /**\n   * Determine if we should stop validating.\n   *\n   * @param  {string} attribute\n   * @param  {boolean} rulePassed\n   * @return {boolean}\n   */\n  _shouldStopValidating: function (attribute, rulePassed) {\n    var stopOnAttributes = this.stopOnAttributes;\n\n    if (typeof stopOnAttributes === 'undefined' || stopOnAttributes === false || rulePassed === true) {\n      return false;\n    }\n\n    if (stopOnAttributes instanceof Array) {\n      return stopOnAttributes.indexOf(attribute) > -1;\n    }\n\n    return true;\n  },\n\n  /**\n   * Set custom attribute names.\n   *\n   * @param {object} attributes\n   * @return {void}\n   */\n  setAttributeNames: function (attributes) {\n    this.messages._setAttributeNames(attributes);\n  },\n\n  /**\n   * Set the attribute formatter.\n   *\n   * @param {fuction} func\n   * @return {void}\n   */\n  setAttributeFormatter: function (func) {\n    this.messages._setAttributeFormatter(func);\n  },\n\n  /**\n   * Get validation rule\n   *\n   * @param  {string} name\n   * @return {Rule}\n   */\n  getRule: function (name) {\n    return Rules.make(name, this);\n  },\n\n  /**\n   * Stop on first error.\n   *\n   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n   * @return {void}\n   */\n  stopOnError: function (attributes) {\n    this.stopOnAttributes = attributes;\n  },\n\n  /**\n   * Determine if validation passes\n   *\n   * @param {function} passes\n   * @return {boolean|undefined}\n   */\n  passes: function (passes) {\n    var async = this._checkAsync('passes', passes);\n\n    if (async) {\n      return this.checkAsync(passes);\n    }\n\n    return this.check();\n  },\n\n  /**\n   * Determine if validation fails\n   *\n   * @param {function} fails\n   * @return {boolean|undefined}\n   */\n  fails: function (fails) {\n    var async = this._checkAsync('fails', fails);\n\n    if (async) {\n      return this.checkAsync(function () {}, fails);\n    }\n\n    return !this.check();\n  },\n\n  /**\n   * Check if validation should be called asynchronously\n   *\n   * @param  {string}   funcName Name of the caller\n   * @param  {function} callback\n   * @return {boolean}\n   */\n  _checkAsync: function (funcName, callback) {\n    var hasCallback = typeof callback === 'function';\n\n    if (this.hasAsync && !hasCallback) {\n      throw funcName + ' expects a callback when async rules are being tested.';\n    }\n\n    return this.hasAsync || hasCallback;\n  }\n};\n/**\n * Set messages for language\n *\n * @param {string} lang\n * @param {object} messages\n * @return {this}\n */\n\nValidator.setMessages = function (lang, messages) {\n  Lang._set(lang, messages);\n\n  return this;\n};\n/**\n * Get messages for given language\n *\n * @param  {string} lang\n * @return {Messages}\n */\n\n\nValidator.getMessages = function (lang) {\n  return Lang._get(lang);\n};\n/**\n * Set default language to use\n *\n * @param {string} lang\n * @return {void}\n */\n\n\nValidator.useLang = function (lang) {\n  this.prototype.lang = lang;\n};\n/**\n * Get default language\n *\n * @return {string}\n */\n\n\nValidator.getDefaultLang = function () {\n  return this.prototype.lang;\n};\n/**\n * Set the attribute formatter.\n *\n * @param {fuction} func\n * @return {void}\n */\n\n\nValidator.setAttributeFormatter = function (func) {\n  this.prototype.attributeFormatter = func;\n};\n/**\n * Stop on first error.\n *\n * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n * @return {void}\n */\n\n\nValidator.stopOnError = function (attributes) {\n  this.prototype.stopOnAttributes = attributes;\n};\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\n\n\nValidator.register = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.register(name, fn);\n\n  Lang._setRuleMessage(lang, name, message);\n};\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @param  {function} fnReplacement\n * @return {void}\n */\n\n\nValidator.registerImplicit = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerImplicit(name, fn);\n\n  Lang._setRuleMessage(lang, name, message);\n};\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\n\n\nValidator.registerAsync = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsync(name, fn);\n\n  Lang._setRuleMessage(lang, name, message);\n};\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\n\n\nValidator.registerAsyncImplicit = function (name, fn, message) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsyncImplicit(name, fn);\n\n  Lang._setRuleMessage(lang, name, message);\n};\n/**\n * Register validator for missed validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\n\n\nValidator.registerMissedRuleValidator = function (fn, message) {\n  Rules.registerMissedRuleValidator(fn, message);\n};\n\nmodule.exports = Validator;","map":{"version":3,"sources":["/Users/erikcamchan/Desktop/TripStagram/client/node_modules/validatorjs/src/validator.js"],"names":["Rules","require","Lang","Errors","Attributes","AsyncResolvers","Validator","input","rules","customMessages","lang","getDefaultLang","messages","_make","_setCustom","setAttributeFormatter","prototype","attributeFormatter","errors","errorCount","hasAsync","_parseRules","constructor","numericRules","formatter","check","self","attribute","attributeRules","inputValue","_objectPath","_hasRule","_suppliedWithData","i","len","length","rule","ruleOptions","rulePassed","getRule","name","_isValidatable","validate","value","_addFailure","_shouldStopValidating","checkAsync","passes","fails","_this","failsOne","message","resolvedAll","allPassed","asyncResolvers","validateRule","resolverIndex","add","resolve","enableFiring","fire","msg","render","_flattenObject","obj","flattened","recurse","current","property","Object","getOwnPropertyNames","Array","isArray","isEmpty","p","path","hasOwnProperty","call","keys","replace","split","copy","attr","l","parsedRules","rulesArray","_parseRulesCheck","wildCardValues","indexOf","_parsedRulesRecurse","_parseRulesDefault","parentPath","substr","propertyValue","propertyNumber","workingValues","slice","push","_prepareRulesArray","_extractRuleAndRuleValue","_replaceWildCards","_replaceWildCardsMessages","isAsync","nums","path2","forEach","pos","key","newKey","ruleString","ruleArray","join","findRules","_hasNumericRule","isImplicit","stopOnAttributes","setAttributeNames","attributes","_setAttributeNames","func","_setAttributeFormatter","make","stopOnError","async","_checkAsync","funcName","callback","hasCallback","setMessages","_set","getMessages","_get","useLang","register","fn","fnReplacement","_setRuleMessage","registerImplicit","registerAsync","registerAsyncImplicit","registerMissedRuleValidator","module","exports"],"mappings":"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","sourcesContent":["var Rules = require('./rules');\nvar Lang = require('./lang');\nvar Errors = require('./errors');\nvar Attributes = require('./attributes');\nvar AsyncResolvers = require('./async');\n\nvar Validator = function (input, rules, customMessages) {\n  var lang = Validator.getDefaultLang();\n  this.input = input || {};\n\n  this.messages = Lang._make(lang);\n  this.messages._setCustom(customMessages);\n  this.setAttributeFormatter(Validator.prototype.attributeFormatter);\n\n  this.errors = new Errors();\n  this.errorCount = 0;\n\n  this.hasAsync = false;\n  this.rules = this._parseRules(rules);\n};\n\nValidator.prototype = {\n\n  constructor: Validator,\n\n  /**\n   * Default language\n   *\n   * @type {string}\n   */\n  lang: 'en',\n\n  /**\n   * Numeric based rules\n   *\n   * @type {array}\n   */\n  numericRules: ['integer', 'numeric'],\n\n  /**\n   * Attribute formatter.\n   *\n   * @type {function}\n   */\n  attributeFormatter: Attributes.formatter,\n\n  /**\n   * Run validator\n   *\n   * @return {boolean} Whether it passes; true = passes, false = fails\n   */\n  check: function () {\n    var self = this;\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {\n        ruleOptions = attributeRules[i];\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);\n        if (!rulePassed) {\n          this._addFailure(rule);\n        }\n\n        if (this._shouldStopValidating(attribute, rulePassed)) {\n          break;\n        }\n      }\n    }\n\n    return this.errorCount === 0;\n  },\n\n  /**\n   * Run async validator\n   *\n   * @param {function} passes\n   * @param {function} fails\n   * @return {void}\n   */\n  checkAsync: function (passes, fails) {\n    var _this = this;\n    passes = passes || function () {};\n    fails = fails || function () {};\n\n    var failsOne = function (rule, message) {\n      _this._addFailure(rule, message);\n    };\n\n    var resolvedAll = function (allPassed) {\n      if (allPassed) {\n        passes();\n      } else {\n        fails();\n      }\n    };\n\n    var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);\n\n    var validateRule = function (inputValue, ruleOptions, attribute, rule) {\n      return function () {\n        var resolverIndex = asyncResolvers.add(rule);\n        rule.validate(inputValue, ruleOptions.value, attribute, function () {\n          asyncResolvers.resolve(resolverIndex);\n        });\n      };\n    };\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {\n        ruleOptions = attributeRules[i];\n\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        validateRule(inputValue, ruleOptions, attribute, rule)();\n      }\n    }\n\n    asyncResolvers.enableFiring();\n    asyncResolvers.fire();\n  },\n\n  /**\n   * Add failure and error message for given rule\n   *\n   * @param {Rule} rule\n   */\n  _addFailure: function (rule) {\n    var msg = this.messages.render(rule);\n    this.errors.add(rule.attribute, msg);\n    this.errorCount++;\n  },\n\n  /**\n   * Flatten nested object, normalizing { foo: { bar: 1 } } into: { 'foo.bar': 1 }\n   *\n   * @param  {object} nested object\n   * @return {object} flattened object\n   */\n  _flattenObject: function (obj) {\n    var flattened = {};\n\n    function recurse(current, property) {\n      if (!property && Object.getOwnPropertyNames(current).length === 0) {\n        return;\n      }\n      if (Object(current) !== current || Array.isArray(current)) {\n        flattened[property] = current;\n      } else {\n        var isEmpty = true;\n        for (var p in current) {\n          isEmpty = false;\n          recurse(current[p], property ? property + '.' + p : p);\n        }\n        if (isEmpty) {\n          flattened[property] = {};\n        }\n      }\n    }\n    if (obj) {\n      recurse(obj);\n    }\n    return flattened;\n  },\n\n  /**\n   * Extract value from nested object using string path with dot notation\n   *\n   * @param  {object} object to search in\n   * @param  {string} path inside object\n   * @return {any|void} value under the path\n   */\n  _objectPath: function (obj, path) {\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n      return obj[path];\n    }\n\n    var keys = path.replace(/\\[(\\w+)\\]/g, '.$1').replace(/^\\./, '').split('.');\n    var copy = {};\n    for (var attr in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n\n    for (var i = 0, l = keys.length; i < l; i++) {\n      if (typeof copy === 'object' && copy !== null && Object.hasOwnProperty.call(copy, keys[i])) {\n        copy = copy[keys[i]];\n      } else {\n        return;\n      }\n    }\n    return copy;\n  },\n\n  /**\n   * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }\n   *\n   * @param  {object} rules\n   * @return {object}\n   */\n  _parseRules: function (rules) {\n\n    var parsedRules = {};\n    rules = this._flattenObject(rules);\n\n    for (var attribute in rules) {\n\n      var rulesArray = rules[attribute];\n\n      this._parseRulesCheck(attribute, rulesArray, parsedRules);\n    }\n    return parsedRules;\n\n\n  },\n\n  _parseRulesCheck: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    if (attribute.indexOf('*') > -1) {\n      this._parsedRulesRecurse(attribute, rulesArray, parsedRules, wildCardValues);\n    } else {\n      this._parseRulesDefault(attribute, rulesArray, parsedRules, wildCardValues);\n    }\n  },\n\n  _parsedRulesRecurse: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var parentPath = attribute.substr(0, attribute.indexOf('*') - 1);\n    var propertyValue = this._objectPath(this.input, parentPath);\n\n    if (propertyValue) {\n      for (var propertyNumber = 0; propertyNumber < propertyValue.length; propertyNumber++) {\n        var workingValues = wildCardValues ? wildCardValues.slice() : [];\n        workingValues.push(propertyNumber);\n        this._parseRulesCheck(attribute.replace('*', propertyNumber), rulesArray, parsedRules, workingValues);\n      }\n    }\n  },\n\n  _parseRulesDefault: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var attributeRules = [];\n\n    if (rulesArray instanceof Array) {\n      rulesArray = this._prepareRulesArray(rulesArray);\n    }\n\n    if (typeof rulesArray === 'string') {\n      rulesArray = rulesArray.split('|');\n    }\n\n    for (var i = 0, len = rulesArray.length, rule; i < len; i++) {\n      rule = typeof rulesArray[i] === 'string' ? this._extractRuleAndRuleValue(rulesArray[i]) : rulesArray[i];\n      if (rule.value) {\n        rule.value = this._replaceWildCards(rule.value, wildCardValues);\n        this._replaceWildCardsMessages(wildCardValues);\n      }\n\n      if (Rules.isAsync(rule.name)) {\n        this.hasAsync = true;\n      }\n      attributeRules.push(rule);\n    }\n\n    parsedRules[attribute] = attributeRules;\n  },\n\n  _replaceWildCards: function (path, nums) {\n\n    if (!nums) {\n      return path;\n    }\n\n    var path2 = path;\n    nums.forEach(function (value) {\n      if(Array.isArray(path2)){\n        path2 = path2[0];\n      }\n      const pos = path2.indexOf('*');\n      if (pos === -1) {\n        return path2;\n      }\n      path2 = path2.substr(0, pos) + value + path2.substr(pos + 1);\n    });\n    if(Array.isArray(path)){\n      path[0] = path2;\n      path2 = path;\n    }\n    return path2;\n  },\n\n  _replaceWildCardsMessages: function (nums) {\n    var customMessages = this.messages.customMessages;\n    var self = this;\n    Object.keys(customMessages).forEach(function (key) {\n      if (nums) {\n        var newKey = self._replaceWildCards(key, nums);\n        customMessages[newKey] = customMessages[key];\n      }\n    });\n\n    this.messages._setCustom(customMessages);\n  },\n  /**\n   * Prepare rules if it comes in Array. Check for objects. Need for type validation.\n   *\n   * @param  {array} rulesArray\n   * @return {array}\n   */\n  _prepareRulesArray: function (rulesArray) {\n    var rules = [];\n\n    for (var i = 0, len = rulesArray.length; i < len; i++) {\n      if (typeof rulesArray[i] === 'object') {\n        for (var rule in rulesArray[i]) {\n          rules.push({\n            name: rule,\n            value: rulesArray[i][rule]\n          });\n        }\n      } else {\n        rules.push(rulesArray[i]);\n      }\n    }\n\n    return rules;\n  },\n\n  /**\n   * Determines if the attribute is supplied with the original data object.\n   *\n   * @param  {array} attribute\n   * @return {boolean}\n   */\n  _suppliedWithData: function (attribute) {\n    return this.input.hasOwnProperty(attribute);\n  },\n\n  /**\n   * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3\n   *\n   * @param  {string} ruleString min:3\n   * @return {object} object containing the name of the rule and value\n   */\n  _extractRuleAndRuleValue: function (ruleString) {\n    var rule = {},\n      ruleArray;\n\n    rule.name = ruleString;\n\n    if (ruleString.indexOf(':') >= 0) {\n      ruleArray = ruleString.split(':');\n      rule.name = ruleArray[0];\n      rule.value = ruleArray.slice(1).join(':');\n    }\n\n    return rule;\n  },\n\n  /**\n   * Determine if attribute has any of the given rules\n   *\n   * @param  {string}  attribute\n   * @param  {array}   findRules\n   * @return {boolean}\n   */\n  _hasRule: function (attribute, findRules) {\n    var rules = this.rules[attribute] || [];\n    for (var i = 0, len = rules.length; i < len; i++) {\n      if (findRules.indexOf(rules[i].name) > -1) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Determine if attribute has any numeric-based rules.\n   *\n   * @param  {string}  attribute\n   * @return {Boolean}\n   */\n  _hasNumericRule: function (attribute) {\n    return this._hasRule(attribute, this.numericRules);\n  },\n\n  /**\n   * Determine if rule is validatable\n   *\n   * @param  {Rule}   rule\n   * @param  {mixed}  value\n   * @return {boolean}\n   */\n  _isValidatable: function (rule, value) {\n    if (Array.isArray(value)) {\n      return true;\n    }\n    if (Rules.isImplicit(rule.name)) {\n      return true;\n    }\n\n    return this.getRule('required').validate(value);\n  },\n\n  /**\n   * Determine if we should stop validating.\n   *\n   * @param  {string} attribute\n   * @param  {boolean} rulePassed\n   * @return {boolean}\n   */\n  _shouldStopValidating: function (attribute, rulePassed) {\n\n    var stopOnAttributes = this.stopOnAttributes;\n    if (typeof stopOnAttributes === 'undefined' || stopOnAttributes === false || rulePassed === true) {\n      return false;\n    }\n\n    if (stopOnAttributes instanceof Array) {\n      return stopOnAttributes.indexOf(attribute) > -1;\n    }\n\n    return true;\n  },\n\n  /**\n   * Set custom attribute names.\n   *\n   * @param {object} attributes\n   * @return {void}\n   */\n  setAttributeNames: function (attributes) {\n    this.messages._setAttributeNames(attributes);\n  },\n\n  /**\n   * Set the attribute formatter.\n   *\n   * @param {fuction} func\n   * @return {void}\n   */\n  setAttributeFormatter: function (func) {\n    this.messages._setAttributeFormatter(func);\n  },\n\n  /**\n   * Get validation rule\n   *\n   * @param  {string} name\n   * @return {Rule}\n   */\n  getRule: function (name) {\n    return Rules.make(name, this);\n  },\n\n  /**\n   * Stop on first error.\n   *\n   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n   * @return {void}\n   */\n  stopOnError: function (attributes) {\n    this.stopOnAttributes = attributes;\n  },\n\n  /**\n   * Determine if validation passes\n   *\n   * @param {function} passes\n   * @return {boolean|undefined}\n   */\n  passes: function (passes) {\n    var async = this._checkAsync('passes', passes);\n    if (async) {\n      return this.checkAsync(passes);\n    }\n    return this.check();\n  },\n\n  /**\n   * Determine if validation fails\n   *\n   * @param {function} fails\n   * @return {boolean|undefined}\n   */\n  fails: function (fails) {\n    var async = this._checkAsync('fails', fails);\n    if (async) {\n      return this.checkAsync(function () {}, fails);\n    }\n    return !this.check();\n  },\n\n  /**\n   * Check if validation should be called asynchronously\n   *\n   * @param  {string}   funcName Name of the caller\n   * @param  {function} callback\n   * @return {boolean}\n   */\n  _checkAsync: function (funcName, callback) {\n    var hasCallback = typeof callback === 'function';\n    if (this.hasAsync && !hasCallback) {\n      throw funcName + ' expects a callback when async rules are being tested.';\n    }\n\n    return this.hasAsync || hasCallback;\n  }\n\n};\n\n/**\n * Set messages for language\n *\n * @param {string} lang\n * @param {object} messages\n * @return {this}\n */\nValidator.setMessages = function (lang, messages) {\n  Lang._set(lang, messages);\n  return this;\n};\n\n/**\n * Get messages for given language\n *\n * @param  {string} lang\n * @return {Messages}\n */\nValidator.getMessages = function (lang) {\n  return Lang._get(lang);\n};\n\n/**\n * Set default language to use\n *\n * @param {string} lang\n * @return {void}\n */\nValidator.useLang = function (lang) {\n  this.prototype.lang = lang;\n};\n\n/**\n * Get default language\n *\n * @return {string}\n */\nValidator.getDefaultLang = function () {\n  return this.prototype.lang;\n};\n\n/**\n * Set the attribute formatter.\n *\n * @param {fuction} func\n * @return {void}\n */\nValidator.setAttributeFormatter = function (func) {\n  this.prototype.attributeFormatter = func;\n};\n\n/**\n * Stop on first error.\n *\n * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n * @return {void}\n */\nValidator.stopOnError = function (attributes) {\n  this.prototype.stopOnAttributes = attributes;\n};\n\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.register = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.register(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @param  {function} fnReplacement\n * @return {void}\n */\nValidator.registerImplicit = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerImplicit(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerAsync = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsync(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerAsyncImplicit = function (name, fn, message) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsyncImplicit(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register validator for missed validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerMissedRuleValidator = function(fn, message) {\n  Rules.registerMissedRuleValidator(fn, message);\n};\n\nmodule.exports = Validator;\n"]},"metadata":{},"sourceType":"script"}