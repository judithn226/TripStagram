{"ast":null,"code":"function AsyncResolvers(onFailedOne, onResolvedAll) {\n  this.onResolvedAll = onResolvedAll;\n  this.onFailedOne = onFailedOne;\n  this.resolvers = {};\n  this.resolversCount = 0;\n  this.passed = [];\n  this.failed = [];\n  this.firing = false;\n}\n\nAsyncResolvers.prototype = {\n  /**\n   * Add resolver\n   *\n   * @param {Rule} rule\n   * @return {integer}\n   */\n  add: function (rule) {\n    var index = this.resolversCount;\n    this.resolvers[index] = rule;\n    this.resolversCount++;\n    return index;\n  },\n\n  /**\n   * Resolve given index\n   *\n   * @param  {integer} index\n   * @return {void}\n   */\n  resolve: function (index) {\n    var rule = this.resolvers[index];\n\n    if (rule.passes === true) {\n      this.passed.push(rule);\n    } else if (rule.passes === false) {\n      this.failed.push(rule);\n      this.onFailedOne(rule);\n    }\n\n    this.fire();\n  },\n\n  /**\n   * Determine if all have been resolved\n   *\n   * @return {boolean}\n   */\n  isAllResolved: function () {\n    return this.passed.length + this.failed.length === this.resolversCount;\n  },\n\n  /**\n   * Attempt to fire final all resolved callback if completed\n   *\n   * @return {void}\n   */\n  fire: function () {\n    if (!this.firing) {\n      return;\n    }\n\n    if (this.isAllResolved()) {\n      this.onResolvedAll(this.failed.length === 0);\n    }\n  },\n\n  /**\n   * Enable firing\n   *\n   * @return {void}\n   */\n  enableFiring: function () {\n    this.firing = true;\n  }\n};\nmodule.exports = AsyncResolvers;","map":{"version":3,"sources":["/Users/judithnwagwu/Documents/TripStagram/client/node_modules/validatorjs/src/async.js"],"names":["AsyncResolvers","onFailedOne","onResolvedAll","resolvers","resolversCount","passed","failed","firing","prototype","add","rule","index","resolve","passes","push","fire","isAllResolved","length","enableFiring","module","exports"],"mappings":"AAAA,SAASA,cAAT,CAAwBC,WAAxB,EAAqCC,aAArC,EAAoD;AAClD,OAAKA,aAAL,GAAqBA,aAArB;AACA,OAAKD,WAAL,GAAmBA,WAAnB;AACA,OAAKE,SAAL,GAAiB,EAAjB;AACA,OAAKC,cAAL,GAAsB,CAAtB;AACA,OAAKC,MAAL,GAAc,EAAd;AACA,OAAKC,MAAL,GAAc,EAAd;AACA,OAAKC,MAAL,GAAc,KAAd;AACD;;AAEDP,cAAc,CAACQ,SAAf,GAA2B;AAEzB;AACF;AACA;AACA;AACA;AACA;AACEC,EAAAA,GAAG,EAAE,UAASC,IAAT,EAAe;AAClB,QAAIC,KAAK,GAAG,KAAKP,cAAjB;AACA,SAAKD,SAAL,CAAeQ,KAAf,IAAwBD,IAAxB;AACA,SAAKN,cAAL;AACA,WAAOO,KAAP;AACD,GAbwB;;AAezB;AACF;AACA;AACA;AACA;AACA;AACEC,EAAAA,OAAO,EAAE,UAASD,KAAT,EAAgB;AACvB,QAAID,IAAI,GAAG,KAAKP,SAAL,CAAeQ,KAAf,CAAX;;AACA,QAAID,IAAI,CAACG,MAAL,KAAgB,IAApB,EAA0B;AACxB,WAAKR,MAAL,CAAYS,IAAZ,CAAiBJ,IAAjB;AACD,KAFD,MAEO,IAAIA,IAAI,CAACG,MAAL,KAAgB,KAApB,EAA2B;AAChC,WAAKP,MAAL,CAAYQ,IAAZ,CAAiBJ,IAAjB;AACA,WAAKT,WAAL,CAAiBS,IAAjB;AACD;;AAED,SAAKK,IAAL;AACD,GA/BwB;;AAiCzB;AACF;AACA;AACA;AACA;AACEC,EAAAA,aAAa,EAAE,YAAW;AACxB,WAAQ,KAAKX,MAAL,CAAYY,MAAZ,GAAqB,KAAKX,MAAL,CAAYW,MAAlC,KAA8C,KAAKb,cAA1D;AACD,GAxCwB;;AA0CzB;AACF;AACA;AACA;AACA;AACEW,EAAAA,IAAI,EAAE,YAAW;AAEf,QAAI,CAAC,KAAKR,MAAV,EAAkB;AAChB;AACD;;AAED,QAAI,KAAKS,aAAL,EAAJ,EAA0B;AACxB,WAAKd,aAAL,CAAmB,KAAKI,MAAL,CAAYW,MAAZ,KAAuB,CAA1C;AACD;AAEF,GAzDwB;;AA2DzB;AACF;AACA;AACA;AACA;AACEC,EAAAA,YAAY,EAAE,YAAW;AACvB,SAAKX,MAAL,GAAc,IAAd;AACD;AAlEwB,CAA3B;AAsEAY,MAAM,CAACC,OAAP,GAAiBpB,cAAjB","sourcesContent":["function AsyncResolvers(onFailedOne, onResolvedAll) {\n  this.onResolvedAll = onResolvedAll;\n  this.onFailedOne = onFailedOne;\n  this.resolvers = {};\n  this.resolversCount = 0;\n  this.passed = [];\n  this.failed = [];\n  this.firing = false;\n}\n\nAsyncResolvers.prototype = {\n\n  /**\n   * Add resolver\n   *\n   * @param {Rule} rule\n   * @return {integer}\n   */\n  add: function(rule) {\n    var index = this.resolversCount;\n    this.resolvers[index] = rule;\n    this.resolversCount++;\n    return index;\n  },\n\n  /**\n   * Resolve given index\n   *\n   * @param  {integer} index\n   * @return {void}\n   */\n  resolve: function(index) {\n    var rule = this.resolvers[index];\n    if (rule.passes === true) {\n      this.passed.push(rule);\n    } else if (rule.passes === false) {\n      this.failed.push(rule);\n      this.onFailedOne(rule);\n    }\n\n    this.fire();\n  },\n\n  /**\n   * Determine if all have been resolved\n   *\n   * @return {boolean}\n   */\n  isAllResolved: function() {\n    return (this.passed.length + this.failed.length) === this.resolversCount;\n  },\n\n  /**\n   * Attempt to fire final all resolved callback if completed\n   *\n   * @return {void}\n   */\n  fire: function() {\n\n    if (!this.firing) {\n      return;\n    }\n\n    if (this.isAllResolved()) {\n      this.onResolvedAll(this.failed.length === 0);\n    }\n\n  },\n\n  /**\n   * Enable firing\n   *\n   * @return {void}\n   */\n  enableFiring: function() {\n    this.firing = true;\n  }\n\n};\n\nmodule.exports = AsyncResolvers;\n"]},"metadata":{},"sourceType":"script"}